package glib

// #include "glib.go.h"
import "C"
import (
	"errors"
	"fmt"
	"reflect"
	"runtime"
	"sync"
	"unsafe"
)

// ValueTransformer is an interface that can be implemented by types bindings C types.
// When converting from go types to GValues, the value is checked for this implementation
// and will use it before considering other options.
type ValueTransformer interface {
	ToGValue() (*Value, error)
}

/*
 * GValue
 */

// Value is a representation of GLib's GValue.
//
// Don't allocate Values on the stack or heap manually as they may not
// be properly unset when going out of scope. Instead, use ValueAlloc(),
// which will set the runtime finalizer to unset the Value after it has
// left scope.
type Value struct {
	GValue *C.GValue
}

// native returns a pointer to the underlying GValue.
func (v *Value) native() *C.GValue {
	return v.GValue
}

// Unsafe returns an unsafe.Pointer to the underlying GValue.
func (v *Value) Unsafe() unsafe.Pointer {
	return unsafe.Pointer(v.native())
}

// Native returns a pointer to the underlying GValue.
func (v *Value) Native() unsafe.Pointer {
	return unsafe.Pointer(v.native())
}

// IsValue checks if value is a valid and initialized GValue structure.
func (v *Value) IsValue() bool {
	return gobool(C._g_is_value(v.native()))
}

// TypeName gets the type name of value.
func (v *Value) TypeName() string {
	return C.GoString((*C.char)(C._g_value_type_name(v.native())))
}

// ValueAlloc allocates a Value and sets a runtime finalizer to call
// g_value_unset() on the underlying GValue after leaving scope.
// ValueAlloc() returns a non-nil error if the allocation failed.
func ValueAlloc() (*Value, error) {
	c := C._g_value_alloc()
	if c == nil {
		return nil, errNilPtr
	}

	v := &Value{c}

	//An allocated GValue is not guaranteed to hold a value that can be unset
	//We need to double check before unsetting, to prevent:
	//`g_value_unset: assertion 'G_IS_VALUE (value)' failed`
	runtime.SetFinalizer(v, func(f *Value) {

		if !f.IsValue() {
			C.g_free(C.gpointer(f.native()))
			return
		}

		f.unset()
	})

	return v, nil
}

// ValueInit is a wrapper around g_value_init() and allocates and
// initializes a new Value with the Type t.  A runtime finalizer is set
// to call g_value_unset() on the underlying GValue after leaving scope.
// ValueInit() returns a non-nil error if the allocation failed.
func ValueInit(t Type) (*Value, error) {
	c := C._g_value_init(C.GType(t))
	if c == nil {
		return nil, errNilPtr
	}
	v := &Value{c}
	runtime.SetFinalizer(v, (*Value).unset)
	return v, nil
}

// ValueFromNative returns a type-asserted pointer to the Value.
func ValueFromNative(l unsafe.Pointer) *Value {
	return &Value{(*C.GValue)(l)}
}

// ValueFromNativeOwned is the same as ValueFromNative except a finalizer
// is placed on the Value afterwards to clear it when it leaves scope.
func ValueFromNativeOwned(l unsafe.Pointer) *Value {
	v := &Value{(*C.GValue)(l)}
	runtime.SetFinalizer(v, (*Value).unset)
	return v
}

func (v *Value) unset() { v.Unset() }

// Unset clears the current value in value (if any) and "unsets" the type, this releases all
// resources associated with this GValue. An unset value is the same as an uninitialized
// (zero-filled) GValue structure.
func (v *Value) Unset() {
	C.g_value_unset(v.native())
	C.g_free((C.gpointer)(unsafe.Pointer(v.native())))
}

// Type is a wrapper around the G_VALUE_HOLDS_GTYPE() macro and
// the g_value_get_gtype() function.  GetType() returns TYPE_INVALID if v
// does not hold a Type, or otherwise returns the Type of v.
func (v *Value) Type() (actual Type, fundamental Type, err error) {
	if !v.IsValue() {
		return actual, fundamental, errors.New("invalid GValue")
	}
	cActual := C._g_value_type(v.native())
	cFundamental := C._g_value_fundamental(cActual)
	return Type(cActual), Type(cFundamental), nil
}

// GValue converts a Go type to a comparable GValue.  GValue()
// returns a non-nil error if the conversion was unsuccessful.
func GValue(v interface{}) (*Value, error) {
	return gValue(v)
}

func gValue(v interface{}) (gvalue *Value, err error) {
	if v == nil {
		val, err := ValueInit(TYPE_POINTER)
		if err != nil {
			return nil, err
		}
		val.SetPointer(unsafe.Pointer(nil))
		return val, nil
	}

	if transformer, ok := v.(ValueTransformer); ok {
		return transformer.ToGValue()
	}

	switch e := v.(type) {
	case bool:
		val, err := ValueInit(TYPE_BOOLEAN)
		if err != nil {
			return nil, err
		}
		val.SetBool(e)
		return val, nil

	case int8:
		val, err := ValueInit(TYPE_CHAR)
		if err != nil {
			return nil, err
		}
		val.SetSChar(e)
		return val, nil

	case int64:
		val, err := ValueInit(TYPE_INT64)
		if err != nil {
			return nil, err
		}
		val.SetInt64(e)
		return val, nil

	case int:
		val, err := ValueInit(TYPE_INT)
		if err != nil {
			return nil, err
		}
		val.SetInt(e)
		return val, nil

	case uint8:
		val, err := ValueInit(TYPE_UCHAR)
		if err != nil {
			return nil, err
		}
		val.SetUChar(e)
		return val, nil

	case uint64:
		val, err := ValueInit(TYPE_UINT64)
		if err != nil {
			return nil, err
		}
		val.SetUInt64(e)
		return val, nil

	case uint:
		val, err := ValueInit(TYPE_UINT)
		if err != nil {
			return nil, err
		}
		val.SetUInt(e)
		return val, nil

	case float32:
		val, err := ValueInit(TYPE_FLOAT)
		if err != nil {
			return nil, err
		}
		val.SetFloat(e)
		return val, nil

	case float64:
		val, err := ValueInit(TYPE_DOUBLE)
		if err != nil {
			return nil, err
		}
		val.SetDouble(e)
		return val, nil

	case string:
		val, err := ValueInit(TYPE_STRING)
		if err != nil {
			return nil, err
		}
		val.SetString(e)
		return val, nil

	case *Object:
		val, err := ValueInit(TYPE_OBJECT)
		if err != nil {
			return nil, err
		}
		val.SetInstance(unsafe.Pointer(e.GObject))
		return val, nil

	case *ParamSpec:
		val, err := ValueInit(TYPE_PARAM)
		if err != nil {
			return nil, err
		}
		return val, nil

	default:
		/* Try this since above doesn't catch constants under other types */
		rval := reflect.ValueOf(v)
		switch rval.Kind() {
		case reflect.Int8:
			val, err := ValueInit(TYPE_CHAR)
			if err != nil {
				return nil, err
			}
			val.SetSChar(int8(rval.Int()))
			return val, nil

		case reflect.Int16:
			return nil, errors.New("Type not implemented")

		case reflect.Int32:
			return nil, errors.New("Type not implemented")

		case reflect.Int64:
			val, err := ValueInit(TYPE_INT64)
			if err != nil {
				return nil, err
			}
			val.SetInt64(rval.Int())
			return val, nil

		case reflect.Int:
			val, err := ValueInit(TYPE_INT)
			if err != nil {
				return nil, err
			}
			val.SetInt(int(rval.Int()))
			return val, nil

		// reflect.Uintptr looks very dangerous here, this could lead to memory errors
		case reflect.Uintptr, reflect.Ptr:
			val, err := ValueInit(TYPE_POINTER)
			if err != nil {
				return nil, err
			}
			// this is a valid cast, see case (5) of https://pkg.go.dev/unsafe#Pointer
			val.SetPointer(unsafe.Pointer(rval.Pointer()))
			return val, nil
		}
	}

	return nil, errors.New("Type not implemented")
}

// GValueMarshaler is a marshal function to convert a GValue into an
// appropriate Go type.  The unsafe.Pointer parameter is a *C.GValue.
type GValueMarshaler func(unsafe.Pointer) (interface{}, error)

// TypeMarshaler represents an actual type and it's associated marshaler.
type TypeMarshaler struct {
	T Type
	F GValueMarshaler
}

// RegisterGValueMarshalers adds marshalers for several types to the
// internal marshalers map. Once registered, calling GoValue on any
// Value with a registered type will return the data returned by the
// marshaler.
func RegisterGValueMarshalers(tm []TypeMarshaler) {
	gValueMarshalers.register(tm)
}

type marshalMap struct {
	marshalMap      map[Type]GValueMarshaler
	criticalSection sync.RWMutex
}

// gValueMarshalers is a map of Glib types to functions to marshal a
// GValue to a native Go type.
var gValueMarshalers = marshalMap{marshalMap: map[Type]GValueMarshaler{
	TYPE_INVALID:   marshalInvalid,
	TYPE_NONE:      marshalNone,
	TYPE_INTERFACE: marshalInterface,
	TYPE_CHAR:      marshalChar,
	TYPE_UCHAR:     marshalUchar,
	TYPE_BOOLEAN:   marshalBoolean,
	TYPE_INT:       marshalInt,
	TYPE_LONG:      marshalLong,
	TYPE_ENUM:      marshalEnum,
	TYPE_INT64:     marshalInt64,
	TYPE_UINT:      marshalUint,
	TYPE_ULONG:     marshalUlong,
	TYPE_FLAGS:     marshalFlags,
	TYPE_UINT64:    marshalUint64,
	TYPE_FLOAT:     marshalFloat,
	TYPE_DOUBLE:    marshalDouble,
	TYPE_STRING:    marshalString,
	TYPE_POINTER:   marshalPointer,
	TYPE_BOXED:     marshalBoxed,
	TYPE_OBJECT:    marshalObject,
	TYPE_VARIANT:   marshalVariant,
	TYPE_PARAM:     marshalParam,
}}

func (m *marshalMap) register(tm []TypeMarshaler) {
	m.criticalSection.Lock()
	defer m.criticalSection.Unlock()

	for i := range tm {
		m.marshalMap[tm[i].T] = tm[i].F
	}
}

func (m *marshalMap) lookup(v *Value) (GValueMarshaler, error) {
	actual, fundamental, err := v.Type()
	if err != nil {
		return nil, err
	}

	m.criticalSection.RLock()
	defer m.criticalSection.RUnlock()

	if f, ok := m.marshalMap[actual]; ok {
		return f, nil
	}
	if f, ok := m.marshalMap[fundamental]; ok {
		return f, nil
	}
	return nil, fmt.Errorf("missing marshaler for type: %s", v.TypeName())
}

func (m *marshalMap) lookupType(t Type) (GValueMarshaler, error) {
	m.criticalSection.RLock()
	defer m.criticalSection.RUnlock()

	if f, ok := m.marshalMap[Type(t)]; ok {
		return f, nil
	}
	return nil, fmt.Errorf("missing marshaler for type: %s", t.Name())
}

func marshalInvalid(unsafe.Pointer) (interface{}, error) {
	return nil, errors.New("invalid type")
}

func marshalNone(unsafe.Pointer) (interface{}, error) {
	return nil, nil
}

func marshalInterface(unsafe.Pointer) (interface{}, error) {
	return nil, errors.New("interface conversion not yet implemented")
}

func marshalChar(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_schar((*C.GValue)(p))
	return int8(c), nil
}

func marshalUchar(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_uchar((*C.GValue)(p))
	return uint8(c), nil
}

func marshalBoolean(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_boolean((*C.GValue)(p))
	return gobool(c), nil
}

func marshalInt(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_int((*C.GValue)(p))
	return int(c), nil
}

func marshalLong(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_long((*C.GValue)(p))
	return int(c), nil
}

func marshalEnum(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_enum((*C.GValue)(p))
	return int(c), nil
}

func marshalInt64(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_int64((*C.GValue)(p))
	return int64(c), nil
}

func marshalUint(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_uint((*C.GValue)(p))
	return uint(c), nil
}

func marshalUlong(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_ulong((*C.GValue)(p))
	return uint(c), nil
}

func marshalFlags(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_flags((*C.GValue)(p))
	return uint(c), nil
}

func marshalUint64(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_uint64((*C.GValue)(p))
	return uint64(c), nil
}

func marshalFloat(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_float((*C.GValue)(p))
	return float32(c), nil
}

func marshalDouble(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_double((*C.GValue)(p))
	return float64(c), nil
}

func marshalString(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_string((*C.GValue)(p))
	return C.GoString((*C.char)(c)), nil
}

func marshalBoxed(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_boxed((*C.GValue)(p))
	return unsafe.Pointer(unsafe.Pointer(c)), nil
}

func marshalPointer(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_pointer((*C.GValue)(p))
	return unsafe.Pointer(c), nil
}

func marshalObject(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_object((*C.GValue)(p))
	return newObject((*C.GObject)(c)), nil
}

func marshalVariant(p unsafe.Pointer) (interface{}, error) {
	return nil, errors.New("variant conversion not yet implemented")
}

func marshalParam(p unsafe.Pointer) (interface{}, error) {
	c := C.g_value_get_param((*C.GValue)(p))
	return newParamSpec((*C.GParamSpec)(c)), nil
}

// GoValue converts a Value to comparable Go type.  GoValue()
// returns a non-nil error if the conversion was unsuccessful.  The
// returned interface{} must be type asserted as the actual Go
// representation of the Value.
//
// This function is a wrapper around the many g_value_get_*()
// functions, depending on the type of the Value. This will return
// non-native go-types if marshalers have been implemented for them.
func (v *Value) GoValue() (interface{}, error) {
	f, err := gValueMarshalers.lookup(v)
	if err != nil {
		return nil, err
	}

	//No need to add finalizer because it is already done by ValueAlloc and ValueInit
	rv, err := f(unsafe.Pointer(v.native()))
	return rv, err
}

// SetBool is a wrapper around g_value_set_boolean().
func (v *Value) SetBool(val bool) {
	C.g_value_set_boolean(v.native(), gbool(val))
}

// SetSChar is a wrapper around g_value_set_schar().
func (v *Value) SetSChar(val int8) {
	C.g_value_set_schar(v.native(), C.gint8(val))
}

// SetInt64 is a wrapper around g_value_set_int64().
func (v *Value) SetInt64(val int64) {
	C.g_value_set_int64(v.native(), C.gint64(val))
}

// SetInt is a wrapper around g_value_set_int().
func (v *Value) SetInt(val int) {
	C.g_value_set_int(v.native(), C.gint(val))
}

// SetUChar is a wrapper around g_value_set_uchar().
func (v *Value) SetUChar(val uint8) {
	C.g_value_set_uchar(v.native(), C.guchar(val))
}

// SetUInt64 is a wrapper around g_value_set_uint64().
func (v *Value) SetUInt64(val uint64) {
	C.g_value_set_uint64(v.native(), C.guint64(val))
}

// SetUInt is a wrapper around g_value_set_uint().
func (v *Value) SetUInt(val uint) {
	C.g_value_set_uint(v.native(), C.guint(val))
}

// SetFloat is a wrapper around g_value_set_float().
func (v *Value) SetFloat(val float32) {
	C.g_value_set_float(v.native(), C.gfloat(val))
}

// SetDouble is a wrapper around g_value_set_double().
func (v *Value) SetDouble(val float64) {
	C.g_value_set_double(v.native(), C.gdouble(val))
}

// SetString is a wrapper around g_value_set_string().
func (v *Value) SetString(val string) {
	cstr := C.CString(val)
	defer C.free(unsafe.Pointer(cstr))
	C.g_value_set_string(v.native(), (*C.gchar)(cstr))
}

// SetInstance is a wrapper around g_value_set_instance().
func (v *Value) SetInstance(instance unsafe.Pointer) {
	C.g_value_set_instance(v.native(), C.gpointer(instance))
}

// SetPointer is a wrapper around g_value_set_pointer().
func (v *Value) SetPointer(p unsafe.Pointer) {
	C.g_value_set_pointer(v.native(), C.gpointer(p))
}

// SetEnum is a wrapper around g_value_set_enum().
func (v *Value) SetEnum(e int) {
	C.g_value_set_enum(v.native(), C.gint(e))
}

// SetParam is a wrapper around g_value_set_param().
func (v *Value) SetParam(p *ParamSpec) {
	C.g_value_set_param(v.native(), p.paramSpec)
}

// SetBoxed is a wrapper around g_value_set_boxed().
func (v *Value) SetBoxed(p unsafe.Pointer) {
	C.g_value_set_boxed(v.native(), C.gconstpointer(p))
}

// TakeBoxed is a wrapper around g_value_take_boxed().
func (v *Value) TakeBoxed(p unsafe.Pointer) {
	C.g_value_take_boxed(v.native(), C.gconstpointer(p))
}

// GetPointer is a wrapper around g_value_get_pointer().
func (v *Value) GetPointer() unsafe.Pointer {
	return unsafe.Pointer(C.g_value_get_pointer(v.native()))
}

// GetString is a wrapper around g_value_get_string().  GetString()
// returns a non-nil error if g_value_get_string() returned a NULL
// pointer to distinguish between returning a NULL pointer and returning
// an empty string.
func (v *Value) GetString() (string, error) {
	c := C.g_value_get_string(v.native())
	if c == nil {
		return "", errNilPtr
	}
	return C.GoString((*C.char)(c)), nil
}
